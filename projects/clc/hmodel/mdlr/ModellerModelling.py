
# Import the Modeller module
from modeller import *
from modeller.automodel import *    

# ---------------------- namelist.dat --------------------------------
# A "namelist.dat" file contains the file names, which was output from 
# the Modeller dialog in Chimera based on user's selection.
# The first line it the name of the target sequence, the remaining 
# lines are name of the template structures
namelist = open( 'namelist.dat', 'r' ).read().split('\n')
tarSeq = namelist[0]
template = tuple( [ x.strip() for x in namelist[1:] if x != '' ] )
# ---------------------- namelist.dat --------------------------------

# This instructs Modeller to display all log output. 
log.verbose()

# create a new Modeller environment
env = environ()

# Directory of atom/PDB/structure files. It is a relative path, inside 
# a temp folder generated by Chimera. User can modify it and add their 
# absolute path containing the structure files.
env.io.atom_files_directory = ['.', './template_struc']

# Read in HETATM records from template PDBs
env.io.hetatm = True
# Read in water molecules from template PDBs
env.io.water = True

# create a subclass of automodel or loopmodel, MyModel.
# user can further modify the MyModel class, to override certain routine.
class MyModel(loopmodel):
	def select_atoms(self):
		from modeller import selection
		return selection(
		self.residue_range('795', '817')
		)
	def select_loop_atoms(self):
		from modeller import selection
		return selection(
		self.residue_range('795', '817')
		)
	def customised_function(self): pass

	#codes override the special_restraints method
	#def special_restraints(self, aln): pass

	#codes override the special_patches method.
	# e.g. to include the addtional disulfides.
	#def special_patches(self, aln): pass

a = MyModel(env,
	# alignment file with template codes and target sequence
	alnfile = 'alignment.ali',
	# name of initial PDB template
	knowns = template[0],
	# code of the target
	sequence = tarSeq)

# one fixed model to base loops on
a.starting_model = 1
a.ending_model = 1

# 10 loop models
loopRefinement = True
a.loop.starting_model = 1
a.loop.ending_model = 10
a.loop.assess_methods=(assess.GA341, assess.normalized_dope)


# Assesses the quality of models using
# the DOPE (Discrete Optimized Protein Energy) method (Shen & Sali 2006)
# and the GA341 method (Melo et al 2002, John & Sali 2003)
a.assess_methods = (assess.GA341, assess.normalized_dope)

# Commented out the fitting since Modeller throws an error if the
# templates don't overlap, and Chimera does the fitting afterward anyway.
# if commented back in, also comment back in the name-fixing about 15
# lines below
## All of the generated models are fit to the templates
#a.final_malign3d = True

# ------------------------- build all models --------------------------
a.make()

# ---------- Accesing output data after modeling is complete ----------

# Get a list of all successfully built models from a.outputs
if loopRefinement:
	ok_models = filter(lambda x: x['failure'] is None, a.loop.outputs)
else:
	ok_models = filter(lambda x: x['failure'] is None, a.outputs)

# Rank the models by index number
def numSort(a, b, key="num"):
	return cmp(a[key], b[key])
ok_models.sort(numSort)

# Output the list of ok_models to file ok_models.dat 
fMoutput = open('ok_models.dat', 'w')
fMoutput.write('File name of aligned model\t GA341\t zDOPE \n')

for m in ok_models:
	# don't adjust name because fitting no longer done by Modeller
	##results  = '%s%s\t' % (m['name'][:-4], '_fit.pdb')  
	results  = '%s\t' % m['name']
	results += '%.5f\t' % m['GA341 score'][0]
	results += '%.5f\n' % m['Normalized DOPE score']
	#results += '%.5f\n' % m['molpdf']
	fMoutput.write( results )

fMoutput.close()
